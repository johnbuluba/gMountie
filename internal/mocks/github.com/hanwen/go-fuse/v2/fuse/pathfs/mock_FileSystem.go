// Code generated by mockery v2.46.3. DO NOT EDIT.

package pathfs

import (
	fuse "github.com/hanwen/go-fuse/v2/fuse"
	mock "github.com/stretchr/testify/mock"

	nodefs "github.com/hanwen/go-fuse/v2/fuse/nodefs"

	pathfs "github.com/hanwen/go-fuse/v2/fuse/pathfs"

	time "time"
)

// MockFileSystem is an autogenerated mock type for the FileSystem type
type MockFileSystem struct {
	mock.Mock
}

type MockFileSystem_Expecter struct {
	mock *mock.Mock
}

func (_m *MockFileSystem) EXPECT() *MockFileSystem_Expecter {
	return &MockFileSystem_Expecter{mock: &_m.Mock}
}

// Access provides a mock function with given fields: name, mode, context
func (_m *MockFileSystem) Access(name string, mode uint32, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, mode, context)

	if len(ret) == 0 {
		panic("no return value specified for Access")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint32, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, mode, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Access_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Access'
type MockFileSystem_Access_Call struct {
	*mock.Call
}

// Access is a helper method to define mock.On call
//   - name string
//   - mode uint32
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Access(name interface{}, mode interface{}, context interface{}) *MockFileSystem_Access_Call {
	return &MockFileSystem_Access_Call{Call: _e.mock.On("Access", name, mode, context)}
}

func (_c *MockFileSystem_Access_Call) Run(run func(name string, mode uint32, context *fuse.Context)) *MockFileSystem_Access_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint32), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Access_Call) Return(code fuse.Status) *MockFileSystem_Access_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Access_Call) RunAndReturn(run func(string, uint32, *fuse.Context) fuse.Status) *MockFileSystem_Access_Call {
	_c.Call.Return(run)
	return _c
}

// Chmod provides a mock function with given fields: name, mode, context
func (_m *MockFileSystem) Chmod(name string, mode uint32, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, mode, context)

	if len(ret) == 0 {
		panic("no return value specified for Chmod")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint32, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, mode, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Chmod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chmod'
type MockFileSystem_Chmod_Call struct {
	*mock.Call
}

// Chmod is a helper method to define mock.On call
//   - name string
//   - mode uint32
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Chmod(name interface{}, mode interface{}, context interface{}) *MockFileSystem_Chmod_Call {
	return &MockFileSystem_Chmod_Call{Call: _e.mock.On("Chmod", name, mode, context)}
}

func (_c *MockFileSystem_Chmod_Call) Run(run func(name string, mode uint32, context *fuse.Context)) *MockFileSystem_Chmod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint32), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Chmod_Call) Return(code fuse.Status) *MockFileSystem_Chmod_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Chmod_Call) RunAndReturn(run func(string, uint32, *fuse.Context) fuse.Status) *MockFileSystem_Chmod_Call {
	_c.Call.Return(run)
	return _c
}

// Chown provides a mock function with given fields: name, uid, gid, context
func (_m *MockFileSystem) Chown(name string, uid uint32, gid uint32, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, uid, gid, context)

	if len(ret) == 0 {
		panic("no return value specified for Chown")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint32, uint32, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, uid, gid, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Chown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chown'
type MockFileSystem_Chown_Call struct {
	*mock.Call
}

// Chown is a helper method to define mock.On call
//   - name string
//   - uid uint32
//   - gid uint32
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Chown(name interface{}, uid interface{}, gid interface{}, context interface{}) *MockFileSystem_Chown_Call {
	return &MockFileSystem_Chown_Call{Call: _e.mock.On("Chown", name, uid, gid, context)}
}

func (_c *MockFileSystem_Chown_Call) Run(run func(name string, uid uint32, gid uint32, context *fuse.Context)) *MockFileSystem_Chown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint32), args[2].(uint32), args[3].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Chown_Call) Return(code fuse.Status) *MockFileSystem_Chown_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Chown_Call) RunAndReturn(run func(string, uint32, uint32, *fuse.Context) fuse.Status) *MockFileSystem_Chown_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: name, flags, mode, context
func (_m *MockFileSystem) Create(name string, flags uint32, mode uint32, context *fuse.Context) (nodefs.File, fuse.Status) {
	ret := _m.Called(name, flags, mode, context)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 nodefs.File
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint32, uint32, *fuse.Context) (nodefs.File, fuse.Status)); ok {
		return rf(name, flags, mode, context)
	}
	if rf, ok := ret.Get(0).(func(string, uint32, uint32, *fuse.Context) nodefs.File); ok {
		r0 = rf(name, flags, mode, context)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nodefs.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string, uint32, uint32, *fuse.Context) fuse.Status); ok {
		r1 = rf(name, flags, mode, context)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFileSystem_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockFileSystem_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - name string
//   - flags uint32
//   - mode uint32
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Create(name interface{}, flags interface{}, mode interface{}, context interface{}) *MockFileSystem_Create_Call {
	return &MockFileSystem_Create_Call{Call: _e.mock.On("Create", name, flags, mode, context)}
}

func (_c *MockFileSystem_Create_Call) Run(run func(name string, flags uint32, mode uint32, context *fuse.Context)) *MockFileSystem_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint32), args[2].(uint32), args[3].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Create_Call) Return(file nodefs.File, code fuse.Status) *MockFileSystem_Create_Call {
	_c.Call.Return(file, code)
	return _c
}

func (_c *MockFileSystem_Create_Call) RunAndReturn(run func(string, uint32, uint32, *fuse.Context) (nodefs.File, fuse.Status)) *MockFileSystem_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetAttr provides a mock function with given fields: name, context
func (_m *MockFileSystem) GetAttr(name string, context *fuse.Context) (*fuse.Attr, fuse.Status) {
	ret := _m.Called(name, context)

	if len(ret) == 0 {
		panic("no return value specified for GetAttr")
	}

	var r0 *fuse.Attr
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) (*fuse.Attr, fuse.Status)); ok {
		return rf(name, context)
	}
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) *fuse.Attr); ok {
		r0 = rf(name, context)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fuse.Attr)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *fuse.Context) fuse.Status); ok {
		r1 = rf(name, context)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFileSystem_GetAttr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAttr'
type MockFileSystem_GetAttr_Call struct {
	*mock.Call
}

// GetAttr is a helper method to define mock.On call
//   - name string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) GetAttr(name interface{}, context interface{}) *MockFileSystem_GetAttr_Call {
	return &MockFileSystem_GetAttr_Call{Call: _e.mock.On("GetAttr", name, context)}
}

func (_c *MockFileSystem_GetAttr_Call) Run(run func(name string, context *fuse.Context)) *MockFileSystem_GetAttr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_GetAttr_Call) Return(_a0 *fuse.Attr, _a1 fuse.Status) *MockFileSystem_GetAttr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFileSystem_GetAttr_Call) RunAndReturn(run func(string, *fuse.Context) (*fuse.Attr, fuse.Status)) *MockFileSystem_GetAttr_Call {
	_c.Call.Return(run)
	return _c
}

// GetXAttr provides a mock function with given fields: name, attribute, context
func (_m *MockFileSystem) GetXAttr(name string, attribute string, context *fuse.Context) ([]byte, fuse.Status) {
	ret := _m.Called(name, attribute, context)

	if len(ret) == 0 {
		panic("no return value specified for GetXAttr")
	}

	var r0 []byte
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func(string, string, *fuse.Context) ([]byte, fuse.Status)); ok {
		return rf(name, attribute, context)
	}
	if rf, ok := ret.Get(0).(func(string, string, *fuse.Context) []byte); ok {
		r0 = rf(name, attribute, context)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *fuse.Context) fuse.Status); ok {
		r1 = rf(name, attribute, context)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFileSystem_GetXAttr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetXAttr'
type MockFileSystem_GetXAttr_Call struct {
	*mock.Call
}

// GetXAttr is a helper method to define mock.On call
//   - name string
//   - attribute string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) GetXAttr(name interface{}, attribute interface{}, context interface{}) *MockFileSystem_GetXAttr_Call {
	return &MockFileSystem_GetXAttr_Call{Call: _e.mock.On("GetXAttr", name, attribute, context)}
}

func (_c *MockFileSystem_GetXAttr_Call) Run(run func(name string, attribute string, context *fuse.Context)) *MockFileSystem_GetXAttr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_GetXAttr_Call) Return(data []byte, code fuse.Status) *MockFileSystem_GetXAttr_Call {
	_c.Call.Return(data, code)
	return _c
}

func (_c *MockFileSystem_GetXAttr_Call) RunAndReturn(run func(string, string, *fuse.Context) ([]byte, fuse.Status)) *MockFileSystem_GetXAttr_Call {
	_c.Call.Return(run)
	return _c
}

// Link provides a mock function with given fields: oldName, newName, context
func (_m *MockFileSystem) Link(oldName string, newName string, context *fuse.Context) fuse.Status {
	ret := _m.Called(oldName, newName, context)

	if len(ret) == 0 {
		panic("no return value specified for Link")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, string, *fuse.Context) fuse.Status); ok {
		r0 = rf(oldName, newName, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Link_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Link'
type MockFileSystem_Link_Call struct {
	*mock.Call
}

// Link is a helper method to define mock.On call
//   - oldName string
//   - newName string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Link(oldName interface{}, newName interface{}, context interface{}) *MockFileSystem_Link_Call {
	return &MockFileSystem_Link_Call{Call: _e.mock.On("Link", oldName, newName, context)}
}

func (_c *MockFileSystem_Link_Call) Run(run func(oldName string, newName string, context *fuse.Context)) *MockFileSystem_Link_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Link_Call) Return(code fuse.Status) *MockFileSystem_Link_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Link_Call) RunAndReturn(run func(string, string, *fuse.Context) fuse.Status) *MockFileSystem_Link_Call {
	_c.Call.Return(run)
	return _c
}

// ListXAttr provides a mock function with given fields: name, context
func (_m *MockFileSystem) ListXAttr(name string, context *fuse.Context) ([]string, fuse.Status) {
	ret := _m.Called(name, context)

	if len(ret) == 0 {
		panic("no return value specified for ListXAttr")
	}

	var r0 []string
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) ([]string, fuse.Status)); ok {
		return rf(name, context)
	}
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) []string); ok {
		r0 = rf(name, context)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *fuse.Context) fuse.Status); ok {
		r1 = rf(name, context)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFileSystem_ListXAttr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListXAttr'
type MockFileSystem_ListXAttr_Call struct {
	*mock.Call
}

// ListXAttr is a helper method to define mock.On call
//   - name string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) ListXAttr(name interface{}, context interface{}) *MockFileSystem_ListXAttr_Call {
	return &MockFileSystem_ListXAttr_Call{Call: _e.mock.On("ListXAttr", name, context)}
}

func (_c *MockFileSystem_ListXAttr_Call) Run(run func(name string, context *fuse.Context)) *MockFileSystem_ListXAttr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_ListXAttr_Call) Return(attributes []string, code fuse.Status) *MockFileSystem_ListXAttr_Call {
	_c.Call.Return(attributes, code)
	return _c
}

func (_c *MockFileSystem_ListXAttr_Call) RunAndReturn(run func(string, *fuse.Context) ([]string, fuse.Status)) *MockFileSystem_ListXAttr_Call {
	_c.Call.Return(run)
	return _c
}

// Mkdir provides a mock function with given fields: name, mode, context
func (_m *MockFileSystem) Mkdir(name string, mode uint32, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, mode, context)

	if len(ret) == 0 {
		panic("no return value specified for Mkdir")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint32, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, mode, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Mkdir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Mkdir'
type MockFileSystem_Mkdir_Call struct {
	*mock.Call
}

// Mkdir is a helper method to define mock.On call
//   - name string
//   - mode uint32
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Mkdir(name interface{}, mode interface{}, context interface{}) *MockFileSystem_Mkdir_Call {
	return &MockFileSystem_Mkdir_Call{Call: _e.mock.On("Mkdir", name, mode, context)}
}

func (_c *MockFileSystem_Mkdir_Call) Run(run func(name string, mode uint32, context *fuse.Context)) *MockFileSystem_Mkdir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint32), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Mkdir_Call) Return(_a0 fuse.Status) *MockFileSystem_Mkdir_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFileSystem_Mkdir_Call) RunAndReturn(run func(string, uint32, *fuse.Context) fuse.Status) *MockFileSystem_Mkdir_Call {
	_c.Call.Return(run)
	return _c
}

// Mknod provides a mock function with given fields: name, mode, dev, context
func (_m *MockFileSystem) Mknod(name string, mode uint32, dev uint32, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, mode, dev, context)

	if len(ret) == 0 {
		panic("no return value specified for Mknod")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint32, uint32, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, mode, dev, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Mknod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Mknod'
type MockFileSystem_Mknod_Call struct {
	*mock.Call
}

// Mknod is a helper method to define mock.On call
//   - name string
//   - mode uint32
//   - dev uint32
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Mknod(name interface{}, mode interface{}, dev interface{}, context interface{}) *MockFileSystem_Mknod_Call {
	return &MockFileSystem_Mknod_Call{Call: _e.mock.On("Mknod", name, mode, dev, context)}
}

func (_c *MockFileSystem_Mknod_Call) Run(run func(name string, mode uint32, dev uint32, context *fuse.Context)) *MockFileSystem_Mknod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint32), args[2].(uint32), args[3].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Mknod_Call) Return(_a0 fuse.Status) *MockFileSystem_Mknod_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFileSystem_Mknod_Call) RunAndReturn(run func(string, uint32, uint32, *fuse.Context) fuse.Status) *MockFileSystem_Mknod_Call {
	_c.Call.Return(run)
	return _c
}

// OnMount provides a mock function with given fields: nodeFs
func (_m *MockFileSystem) OnMount(nodeFs *pathfs.PathNodeFs) {
	_m.Called(nodeFs)
}

// MockFileSystem_OnMount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnMount'
type MockFileSystem_OnMount_Call struct {
	*mock.Call
}

// OnMount is a helper method to define mock.On call
//   - nodeFs *pathfs.PathNodeFs
func (_e *MockFileSystem_Expecter) OnMount(nodeFs interface{}) *MockFileSystem_OnMount_Call {
	return &MockFileSystem_OnMount_Call{Call: _e.mock.On("OnMount", nodeFs)}
}

func (_c *MockFileSystem_OnMount_Call) Run(run func(nodeFs *pathfs.PathNodeFs)) *MockFileSystem_OnMount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*pathfs.PathNodeFs))
	})
	return _c
}

func (_c *MockFileSystem_OnMount_Call) Return() *MockFileSystem_OnMount_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockFileSystem_OnMount_Call) RunAndReturn(run func(*pathfs.PathNodeFs)) *MockFileSystem_OnMount_Call {
	_c.Call.Return(run)
	return _c
}

// OnUnmount provides a mock function with given fields:
func (_m *MockFileSystem) OnUnmount() {
	_m.Called()
}

// MockFileSystem_OnUnmount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnUnmount'
type MockFileSystem_OnUnmount_Call struct {
	*mock.Call
}

// OnUnmount is a helper method to define mock.On call
func (_e *MockFileSystem_Expecter) OnUnmount() *MockFileSystem_OnUnmount_Call {
	return &MockFileSystem_OnUnmount_Call{Call: _e.mock.On("OnUnmount")}
}

func (_c *MockFileSystem_OnUnmount_Call) Run(run func()) *MockFileSystem_OnUnmount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockFileSystem_OnUnmount_Call) Return() *MockFileSystem_OnUnmount_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockFileSystem_OnUnmount_Call) RunAndReturn(run func()) *MockFileSystem_OnUnmount_Call {
	_c.Call.Return(run)
	return _c
}

// Open provides a mock function with given fields: name, flags, context
func (_m *MockFileSystem) Open(name string, flags uint32, context *fuse.Context) (nodefs.File, fuse.Status) {
	ret := _m.Called(name, flags, context)

	if len(ret) == 0 {
		panic("no return value specified for Open")
	}

	var r0 nodefs.File
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint32, *fuse.Context) (nodefs.File, fuse.Status)); ok {
		return rf(name, flags, context)
	}
	if rf, ok := ret.Get(0).(func(string, uint32, *fuse.Context) nodefs.File); ok {
		r0 = rf(name, flags, context)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nodefs.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string, uint32, *fuse.Context) fuse.Status); ok {
		r1 = rf(name, flags, context)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFileSystem_Open_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Open'
type MockFileSystem_Open_Call struct {
	*mock.Call
}

// Open is a helper method to define mock.On call
//   - name string
//   - flags uint32
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Open(name interface{}, flags interface{}, context interface{}) *MockFileSystem_Open_Call {
	return &MockFileSystem_Open_Call{Call: _e.mock.On("Open", name, flags, context)}
}

func (_c *MockFileSystem_Open_Call) Run(run func(name string, flags uint32, context *fuse.Context)) *MockFileSystem_Open_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint32), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Open_Call) Return(file nodefs.File, code fuse.Status) *MockFileSystem_Open_Call {
	_c.Call.Return(file, code)
	return _c
}

func (_c *MockFileSystem_Open_Call) RunAndReturn(run func(string, uint32, *fuse.Context) (nodefs.File, fuse.Status)) *MockFileSystem_Open_Call {
	_c.Call.Return(run)
	return _c
}

// OpenDir provides a mock function with given fields: name, context
func (_m *MockFileSystem) OpenDir(name string, context *fuse.Context) ([]fuse.DirEntry, fuse.Status) {
	ret := _m.Called(name, context)

	if len(ret) == 0 {
		panic("no return value specified for OpenDir")
	}

	var r0 []fuse.DirEntry
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) ([]fuse.DirEntry, fuse.Status)); ok {
		return rf(name, context)
	}
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) []fuse.DirEntry); ok {
		r0 = rf(name, context)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]fuse.DirEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *fuse.Context) fuse.Status); ok {
		r1 = rf(name, context)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFileSystem_OpenDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenDir'
type MockFileSystem_OpenDir_Call struct {
	*mock.Call
}

// OpenDir is a helper method to define mock.On call
//   - name string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) OpenDir(name interface{}, context interface{}) *MockFileSystem_OpenDir_Call {
	return &MockFileSystem_OpenDir_Call{Call: _e.mock.On("OpenDir", name, context)}
}

func (_c *MockFileSystem_OpenDir_Call) Run(run func(name string, context *fuse.Context)) *MockFileSystem_OpenDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_OpenDir_Call) Return(stream []fuse.DirEntry, code fuse.Status) *MockFileSystem_OpenDir_Call {
	_c.Call.Return(stream, code)
	return _c
}

func (_c *MockFileSystem_OpenDir_Call) RunAndReturn(run func(string, *fuse.Context) ([]fuse.DirEntry, fuse.Status)) *MockFileSystem_OpenDir_Call {
	_c.Call.Return(run)
	return _c
}

// Readlink provides a mock function with given fields: name, context
func (_m *MockFileSystem) Readlink(name string, context *fuse.Context) (string, fuse.Status) {
	ret := _m.Called(name, context)

	if len(ret) == 0 {
		panic("no return value specified for Readlink")
	}

	var r0 string
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) (string, fuse.Status)); ok {
		return rf(name, context)
	}
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) string); ok {
		r0 = rf(name, context)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, *fuse.Context) fuse.Status); ok {
		r1 = rf(name, context)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFileSystem_Readlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Readlink'
type MockFileSystem_Readlink_Call struct {
	*mock.Call
}

// Readlink is a helper method to define mock.On call
//   - name string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Readlink(name interface{}, context interface{}) *MockFileSystem_Readlink_Call {
	return &MockFileSystem_Readlink_Call{Call: _e.mock.On("Readlink", name, context)}
}

func (_c *MockFileSystem_Readlink_Call) Run(run func(name string, context *fuse.Context)) *MockFileSystem_Readlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Readlink_Call) Return(_a0 string, _a1 fuse.Status) *MockFileSystem_Readlink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFileSystem_Readlink_Call) RunAndReturn(run func(string, *fuse.Context) (string, fuse.Status)) *MockFileSystem_Readlink_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveXAttr provides a mock function with given fields: name, attr, context
func (_m *MockFileSystem) RemoveXAttr(name string, attr string, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, attr, context)

	if len(ret) == 0 {
		panic("no return value specified for RemoveXAttr")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, string, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, attr, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_RemoveXAttr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveXAttr'
type MockFileSystem_RemoveXAttr_Call struct {
	*mock.Call
}

// RemoveXAttr is a helper method to define mock.On call
//   - name string
//   - attr string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) RemoveXAttr(name interface{}, attr interface{}, context interface{}) *MockFileSystem_RemoveXAttr_Call {
	return &MockFileSystem_RemoveXAttr_Call{Call: _e.mock.On("RemoveXAttr", name, attr, context)}
}

func (_c *MockFileSystem_RemoveXAttr_Call) Run(run func(name string, attr string, context *fuse.Context)) *MockFileSystem_RemoveXAttr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_RemoveXAttr_Call) Return(_a0 fuse.Status) *MockFileSystem_RemoveXAttr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFileSystem_RemoveXAttr_Call) RunAndReturn(run func(string, string, *fuse.Context) fuse.Status) *MockFileSystem_RemoveXAttr_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function with given fields: oldName, newName, context
func (_m *MockFileSystem) Rename(oldName string, newName string, context *fuse.Context) fuse.Status {
	ret := _m.Called(oldName, newName, context)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, string, *fuse.Context) fuse.Status); ok {
		r0 = rf(oldName, newName, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type MockFileSystem_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - oldName string
//   - newName string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Rename(oldName interface{}, newName interface{}, context interface{}) *MockFileSystem_Rename_Call {
	return &MockFileSystem_Rename_Call{Call: _e.mock.On("Rename", oldName, newName, context)}
}

func (_c *MockFileSystem_Rename_Call) Run(run func(oldName string, newName string, context *fuse.Context)) *MockFileSystem_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Rename_Call) Return(code fuse.Status) *MockFileSystem_Rename_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Rename_Call) RunAndReturn(run func(string, string, *fuse.Context) fuse.Status) *MockFileSystem_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// Rmdir provides a mock function with given fields: name, context
func (_m *MockFileSystem) Rmdir(name string, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, context)

	if len(ret) == 0 {
		panic("no return value specified for Rmdir")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Rmdir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rmdir'
type MockFileSystem_Rmdir_Call struct {
	*mock.Call
}

// Rmdir is a helper method to define mock.On call
//   - name string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Rmdir(name interface{}, context interface{}) *MockFileSystem_Rmdir_Call {
	return &MockFileSystem_Rmdir_Call{Call: _e.mock.On("Rmdir", name, context)}
}

func (_c *MockFileSystem_Rmdir_Call) Run(run func(name string, context *fuse.Context)) *MockFileSystem_Rmdir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Rmdir_Call) Return(code fuse.Status) *MockFileSystem_Rmdir_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Rmdir_Call) RunAndReturn(run func(string, *fuse.Context) fuse.Status) *MockFileSystem_Rmdir_Call {
	_c.Call.Return(run)
	return _c
}

// SetDebug provides a mock function with given fields: debug
func (_m *MockFileSystem) SetDebug(debug bool) {
	_m.Called(debug)
}

// MockFileSystem_SetDebug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDebug'
type MockFileSystem_SetDebug_Call struct {
	*mock.Call
}

// SetDebug is a helper method to define mock.On call
//   - debug bool
func (_e *MockFileSystem_Expecter) SetDebug(debug interface{}) *MockFileSystem_SetDebug_Call {
	return &MockFileSystem_SetDebug_Call{Call: _e.mock.On("SetDebug", debug)}
}

func (_c *MockFileSystem_SetDebug_Call) Run(run func(debug bool)) *MockFileSystem_SetDebug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *MockFileSystem_SetDebug_Call) Return() *MockFileSystem_SetDebug_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockFileSystem_SetDebug_Call) RunAndReturn(run func(bool)) *MockFileSystem_SetDebug_Call {
	_c.Call.Return(run)
	return _c
}

// SetXAttr provides a mock function with given fields: name, attr, data, flags, context
func (_m *MockFileSystem) SetXAttr(name string, attr string, data []byte, flags int, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, attr, data, flags, context)

	if len(ret) == 0 {
		panic("no return value specified for SetXAttr")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, string, []byte, int, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, attr, data, flags, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_SetXAttr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetXAttr'
type MockFileSystem_SetXAttr_Call struct {
	*mock.Call
}

// SetXAttr is a helper method to define mock.On call
//   - name string
//   - attr string
//   - data []byte
//   - flags int
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) SetXAttr(name interface{}, attr interface{}, data interface{}, flags interface{}, context interface{}) *MockFileSystem_SetXAttr_Call {
	return &MockFileSystem_SetXAttr_Call{Call: _e.mock.On("SetXAttr", name, attr, data, flags, context)}
}

func (_c *MockFileSystem_SetXAttr_Call) Run(run func(name string, attr string, data []byte, flags int, context *fuse.Context)) *MockFileSystem_SetXAttr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]byte), args[3].(int), args[4].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_SetXAttr_Call) Return(_a0 fuse.Status) *MockFileSystem_SetXAttr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFileSystem_SetXAttr_Call) RunAndReturn(run func(string, string, []byte, int, *fuse.Context) fuse.Status) *MockFileSystem_SetXAttr_Call {
	_c.Call.Return(run)
	return _c
}

// StatFs provides a mock function with given fields: name
func (_m *MockFileSystem) StatFs(name string) *fuse.StatfsOut {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for StatFs")
	}

	var r0 *fuse.StatfsOut
	if rf, ok := ret.Get(0).(func(string) *fuse.StatfsOut); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fuse.StatfsOut)
		}
	}

	return r0
}

// MockFileSystem_StatFs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatFs'
type MockFileSystem_StatFs_Call struct {
	*mock.Call
}

// StatFs is a helper method to define mock.On call
//   - name string
func (_e *MockFileSystem_Expecter) StatFs(name interface{}) *MockFileSystem_StatFs_Call {
	return &MockFileSystem_StatFs_Call{Call: _e.mock.On("StatFs", name)}
}

func (_c *MockFileSystem_StatFs_Call) Run(run func(name string)) *MockFileSystem_StatFs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockFileSystem_StatFs_Call) Return(_a0 *fuse.StatfsOut) *MockFileSystem_StatFs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFileSystem_StatFs_Call) RunAndReturn(run func(string) *fuse.StatfsOut) *MockFileSystem_StatFs_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields:
func (_m *MockFileSystem) String() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockFileSystem_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type MockFileSystem_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *MockFileSystem_Expecter) String() *MockFileSystem_String_Call {
	return &MockFileSystem_String_Call{Call: _e.mock.On("String")}
}

func (_c *MockFileSystem_String_Call) Run(run func()) *MockFileSystem_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockFileSystem_String_Call) Return(_a0 string) *MockFileSystem_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFileSystem_String_Call) RunAndReturn(run func() string) *MockFileSystem_String_Call {
	_c.Call.Return(run)
	return _c
}

// Symlink provides a mock function with given fields: value, linkName, context
func (_m *MockFileSystem) Symlink(value string, linkName string, context *fuse.Context) fuse.Status {
	ret := _m.Called(value, linkName, context)

	if len(ret) == 0 {
		panic("no return value specified for Symlink")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, string, *fuse.Context) fuse.Status); ok {
		r0 = rf(value, linkName, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Symlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Symlink'
type MockFileSystem_Symlink_Call struct {
	*mock.Call
}

// Symlink is a helper method to define mock.On call
//   - value string
//   - linkName string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Symlink(value interface{}, linkName interface{}, context interface{}) *MockFileSystem_Symlink_Call {
	return &MockFileSystem_Symlink_Call{Call: _e.mock.On("Symlink", value, linkName, context)}
}

func (_c *MockFileSystem_Symlink_Call) Run(run func(value string, linkName string, context *fuse.Context)) *MockFileSystem_Symlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Symlink_Call) Return(code fuse.Status) *MockFileSystem_Symlink_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Symlink_Call) RunAndReturn(run func(string, string, *fuse.Context) fuse.Status) *MockFileSystem_Symlink_Call {
	_c.Call.Return(run)
	return _c
}

// Truncate provides a mock function with given fields: name, size, context
func (_m *MockFileSystem) Truncate(name string, size uint64, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, size, context)

	if len(ret) == 0 {
		panic("no return value specified for Truncate")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, uint64, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, size, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Truncate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Truncate'
type MockFileSystem_Truncate_Call struct {
	*mock.Call
}

// Truncate is a helper method to define mock.On call
//   - name string
//   - size uint64
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Truncate(name interface{}, size interface{}, context interface{}) *MockFileSystem_Truncate_Call {
	return &MockFileSystem_Truncate_Call{Call: _e.mock.On("Truncate", name, size, context)}
}

func (_c *MockFileSystem_Truncate_Call) Run(run func(name string, size uint64, context *fuse.Context)) *MockFileSystem_Truncate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint64), args[2].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Truncate_Call) Return(code fuse.Status) *MockFileSystem_Truncate_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Truncate_Call) RunAndReturn(run func(string, uint64, *fuse.Context) fuse.Status) *MockFileSystem_Truncate_Call {
	_c.Call.Return(run)
	return _c
}

// Unlink provides a mock function with given fields: name, context
func (_m *MockFileSystem) Unlink(name string, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, context)

	if len(ret) == 0 {
		panic("no return value specified for Unlink")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Unlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unlink'
type MockFileSystem_Unlink_Call struct {
	*mock.Call
}

// Unlink is a helper method to define mock.On call
//   - name string
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Unlink(name interface{}, context interface{}) *MockFileSystem_Unlink_Call {
	return &MockFileSystem_Unlink_Call{Call: _e.mock.On("Unlink", name, context)}
}

func (_c *MockFileSystem_Unlink_Call) Run(run func(name string, context *fuse.Context)) *MockFileSystem_Unlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Unlink_Call) Return(code fuse.Status) *MockFileSystem_Unlink_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Unlink_Call) RunAndReturn(run func(string, *fuse.Context) fuse.Status) *MockFileSystem_Unlink_Call {
	_c.Call.Return(run)
	return _c
}

// Utimens provides a mock function with given fields: name, Atime, Mtime, context
func (_m *MockFileSystem) Utimens(name string, Atime *time.Time, Mtime *time.Time, context *fuse.Context) fuse.Status {
	ret := _m.Called(name, Atime, Mtime, context)

	if len(ret) == 0 {
		panic("no return value specified for Utimens")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(string, *time.Time, *time.Time, *fuse.Context) fuse.Status); ok {
		r0 = rf(name, Atime, Mtime, context)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFileSystem_Utimens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Utimens'
type MockFileSystem_Utimens_Call struct {
	*mock.Call
}

// Utimens is a helper method to define mock.On call
//   - name string
//   - Atime *time.Time
//   - Mtime *time.Time
//   - context *fuse.Context
func (_e *MockFileSystem_Expecter) Utimens(name interface{}, Atime interface{}, Mtime interface{}, context interface{}) *MockFileSystem_Utimens_Call {
	return &MockFileSystem_Utimens_Call{Call: _e.mock.On("Utimens", name, Atime, Mtime, context)}
}

func (_c *MockFileSystem_Utimens_Call) Run(run func(name string, Atime *time.Time, Mtime *time.Time, context *fuse.Context)) *MockFileSystem_Utimens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*time.Time), args[2].(*time.Time), args[3].(*fuse.Context))
	})
	return _c
}

func (_c *MockFileSystem_Utimens_Call) Return(code fuse.Status) *MockFileSystem_Utimens_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFileSystem_Utimens_Call) RunAndReturn(run func(string, *time.Time, *time.Time, *fuse.Context) fuse.Status) *MockFileSystem_Utimens_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockFileSystem creates a new instance of MockFileSystem. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFileSystem(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFileSystem {
	mock := &MockFileSystem{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

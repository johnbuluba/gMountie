// Code generated by mockery v2.46.3. DO NOT EDIT.

package nodefs

import (
	fuse "github.com/hanwen/go-fuse/v2/fuse"
	mock "github.com/stretchr/testify/mock"

	nodefs "github.com/hanwen/go-fuse/v2/fuse/nodefs"

	time "time"
)

// MockFile is an autogenerated mock type for the File type
type MockFile struct {
	mock.Mock
}

type MockFile_Expecter struct {
	mock *mock.Mock
}

func (_m *MockFile) EXPECT() *MockFile_Expecter {
	return &MockFile_Expecter{mock: &_m.Mock}
}

// Allocate provides a mock function with given fields: off, size, mode
func (_m *MockFile) Allocate(off uint64, size uint64, mode uint32) fuse.Status {
	ret := _m.Called(off, size, mode)

	if len(ret) == 0 {
		panic("no return value specified for Allocate")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(uint64, uint64, uint32) fuse.Status); ok {
		r0 = rf(off, size, mode)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_Allocate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Allocate'
type MockFile_Allocate_Call struct {
	*mock.Call
}

// Allocate is a helper method to define mock.On call
//   - off uint64
//   - size uint64
//   - mode uint32
func (_e *MockFile_Expecter) Allocate(off interface{}, size interface{}, mode interface{}) *MockFile_Allocate_Call {
	return &MockFile_Allocate_Call{Call: _e.mock.On("Allocate", off, size, mode)}
}

func (_c *MockFile_Allocate_Call) Run(run func(off uint64, size uint64, mode uint32)) *MockFile_Allocate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(uint64), args[2].(uint32))
	})
	return _c
}

func (_c *MockFile_Allocate_Call) Return(code fuse.Status) *MockFile_Allocate_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFile_Allocate_Call) RunAndReturn(run func(uint64, uint64, uint32) fuse.Status) *MockFile_Allocate_Call {
	_c.Call.Return(run)
	return _c
}

// Chmod provides a mock function with given fields: perms
func (_m *MockFile) Chmod(perms uint32) fuse.Status {
	ret := _m.Called(perms)

	if len(ret) == 0 {
		panic("no return value specified for Chmod")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(uint32) fuse.Status); ok {
		r0 = rf(perms)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_Chmod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chmod'
type MockFile_Chmod_Call struct {
	*mock.Call
}

// Chmod is a helper method to define mock.On call
//   - perms uint32
func (_e *MockFile_Expecter) Chmod(perms interface{}) *MockFile_Chmod_Call {
	return &MockFile_Chmod_Call{Call: _e.mock.On("Chmod", perms)}
}

func (_c *MockFile_Chmod_Call) Run(run func(perms uint32)) *MockFile_Chmod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32))
	})
	return _c
}

func (_c *MockFile_Chmod_Call) Return(_a0 fuse.Status) *MockFile_Chmod_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_Chmod_Call) RunAndReturn(run func(uint32) fuse.Status) *MockFile_Chmod_Call {
	_c.Call.Return(run)
	return _c
}

// Chown provides a mock function with given fields: uid, gid
func (_m *MockFile) Chown(uid uint32, gid uint32) fuse.Status {
	ret := _m.Called(uid, gid)

	if len(ret) == 0 {
		panic("no return value specified for Chown")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(uint32, uint32) fuse.Status); ok {
		r0 = rf(uid, gid)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_Chown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chown'
type MockFile_Chown_Call struct {
	*mock.Call
}

// Chown is a helper method to define mock.On call
//   - uid uint32
//   - gid uint32
func (_e *MockFile_Expecter) Chown(uid interface{}, gid interface{}) *MockFile_Chown_Call {
	return &MockFile_Chown_Call{Call: _e.mock.On("Chown", uid, gid)}
}

func (_c *MockFile_Chown_Call) Run(run func(uid uint32, gid uint32)) *MockFile_Chown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32), args[1].(uint32))
	})
	return _c
}

func (_c *MockFile_Chown_Call) Return(_a0 fuse.Status) *MockFile_Chown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_Chown_Call) RunAndReturn(run func(uint32, uint32) fuse.Status) *MockFile_Chown_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function with given fields:
func (_m *MockFile) Flush() fuse.Status {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func() fuse.Status); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MockFile_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *MockFile_Expecter) Flush() *MockFile_Flush_Call {
	return &MockFile_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *MockFile_Flush_Call) Run(run func()) *MockFile_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockFile_Flush_Call) Return(_a0 fuse.Status) *MockFile_Flush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_Flush_Call) RunAndReturn(run func() fuse.Status) *MockFile_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// Fsync provides a mock function with given fields: flags
func (_m *MockFile) Fsync(flags int) fuse.Status {
	ret := _m.Called(flags)

	if len(ret) == 0 {
		panic("no return value specified for Fsync")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(int) fuse.Status); ok {
		r0 = rf(flags)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_Fsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fsync'
type MockFile_Fsync_Call struct {
	*mock.Call
}

// Fsync is a helper method to define mock.On call
//   - flags int
func (_e *MockFile_Expecter) Fsync(flags interface{}) *MockFile_Fsync_Call {
	return &MockFile_Fsync_Call{Call: _e.mock.On("Fsync", flags)}
}

func (_c *MockFile_Fsync_Call) Run(run func(flags int)) *MockFile_Fsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *MockFile_Fsync_Call) Return(code fuse.Status) *MockFile_Fsync_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFile_Fsync_Call) RunAndReturn(run func(int) fuse.Status) *MockFile_Fsync_Call {
	_c.Call.Return(run)
	return _c
}

// GetAttr provides a mock function with given fields: out
func (_m *MockFile) GetAttr(out *fuse.Attr) fuse.Status {
	ret := _m.Called(out)

	if len(ret) == 0 {
		panic("no return value specified for GetAttr")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(*fuse.Attr) fuse.Status); ok {
		r0 = rf(out)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_GetAttr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAttr'
type MockFile_GetAttr_Call struct {
	*mock.Call
}

// GetAttr is a helper method to define mock.On call
//   - out *fuse.Attr
func (_e *MockFile_Expecter) GetAttr(out interface{}) *MockFile_GetAttr_Call {
	return &MockFile_GetAttr_Call{Call: _e.mock.On("GetAttr", out)}
}

func (_c *MockFile_GetAttr_Call) Run(run func(out *fuse.Attr)) *MockFile_GetAttr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*fuse.Attr))
	})
	return _c
}

func (_c *MockFile_GetAttr_Call) Return(_a0 fuse.Status) *MockFile_GetAttr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_GetAttr_Call) RunAndReturn(run func(*fuse.Attr) fuse.Status) *MockFile_GetAttr_Call {
	_c.Call.Return(run)
	return _c
}

// GetLk provides a mock function with given fields: owner, lk, flags, out
func (_m *MockFile) GetLk(owner uint64, lk *fuse.FileLock, flags uint32, out *fuse.FileLock) fuse.Status {
	ret := _m.Called(owner, lk, flags, out)

	if len(ret) == 0 {
		panic("no return value specified for GetLk")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(uint64, *fuse.FileLock, uint32, *fuse.FileLock) fuse.Status); ok {
		r0 = rf(owner, lk, flags, out)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_GetLk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLk'
type MockFile_GetLk_Call struct {
	*mock.Call
}

// GetLk is a helper method to define mock.On call
//   - owner uint64
//   - lk *fuse.FileLock
//   - flags uint32
//   - out *fuse.FileLock
func (_e *MockFile_Expecter) GetLk(owner interface{}, lk interface{}, flags interface{}, out interface{}) *MockFile_GetLk_Call {
	return &MockFile_GetLk_Call{Call: _e.mock.On("GetLk", owner, lk, flags, out)}
}

func (_c *MockFile_GetLk_Call) Run(run func(owner uint64, lk *fuse.FileLock, flags uint32, out *fuse.FileLock)) *MockFile_GetLk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(*fuse.FileLock), args[2].(uint32), args[3].(*fuse.FileLock))
	})
	return _c
}

func (_c *MockFile_GetLk_Call) Return(code fuse.Status) *MockFile_GetLk_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFile_GetLk_Call) RunAndReturn(run func(uint64, *fuse.FileLock, uint32, *fuse.FileLock) fuse.Status) *MockFile_GetLk_Call {
	_c.Call.Return(run)
	return _c
}

// InnerFile provides a mock function with given fields:
func (_m *MockFile) InnerFile() nodefs.File {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InnerFile")
	}

	var r0 nodefs.File
	if rf, ok := ret.Get(0).(func() nodefs.File); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nodefs.File)
		}
	}

	return r0
}

// MockFile_InnerFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InnerFile'
type MockFile_InnerFile_Call struct {
	*mock.Call
}

// InnerFile is a helper method to define mock.On call
func (_e *MockFile_Expecter) InnerFile() *MockFile_InnerFile_Call {
	return &MockFile_InnerFile_Call{Call: _e.mock.On("InnerFile")}
}

func (_c *MockFile_InnerFile_Call) Run(run func()) *MockFile_InnerFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockFile_InnerFile_Call) Return(_a0 nodefs.File) *MockFile_InnerFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_InnerFile_Call) RunAndReturn(run func() nodefs.File) *MockFile_InnerFile_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function with given fields: dest, off
func (_m *MockFile) Read(dest []byte, off int64) (fuse.ReadResult, fuse.Status) {
	ret := _m.Called(dest, off)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 fuse.ReadResult
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func([]byte, int64) (fuse.ReadResult, fuse.Status)); ok {
		return rf(dest, off)
	}
	if rf, ok := ret.Get(0).(func([]byte, int64) fuse.ReadResult); ok {
		r0 = rf(dest, off)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fuse.ReadResult)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, int64) fuse.Status); ok {
		r1 = rf(dest, off)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFile_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockFile_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - dest []byte
//   - off int64
func (_e *MockFile_Expecter) Read(dest interface{}, off interface{}) *MockFile_Read_Call {
	return &MockFile_Read_Call{Call: _e.mock.On("Read", dest, off)}
}

func (_c *MockFile_Read_Call) Run(run func(dest []byte, off int64)) *MockFile_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(int64))
	})
	return _c
}

func (_c *MockFile_Read_Call) Return(_a0 fuse.ReadResult, _a1 fuse.Status) *MockFile_Read_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFile_Read_Call) RunAndReturn(run func([]byte, int64) (fuse.ReadResult, fuse.Status)) *MockFile_Read_Call {
	_c.Call.Return(run)
	return _c
}

// Release provides a mock function with given fields:
func (_m *MockFile) Release() {
	_m.Called()
}

// MockFile_Release_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Release'
type MockFile_Release_Call struct {
	*mock.Call
}

// Release is a helper method to define mock.On call
func (_e *MockFile_Expecter) Release() *MockFile_Release_Call {
	return &MockFile_Release_Call{Call: _e.mock.On("Release")}
}

func (_c *MockFile_Release_Call) Run(run func()) *MockFile_Release_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockFile_Release_Call) Return() *MockFile_Release_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockFile_Release_Call) RunAndReturn(run func()) *MockFile_Release_Call {
	_c.Call.Return(run)
	return _c
}

// SetInode provides a mock function with given fields: _a0
func (_m *MockFile) SetInode(_a0 *nodefs.Inode) {
	_m.Called(_a0)
}

// MockFile_SetInode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetInode'
type MockFile_SetInode_Call struct {
	*mock.Call
}

// SetInode is a helper method to define mock.On call
//   - _a0 *nodefs.Inode
func (_e *MockFile_Expecter) SetInode(_a0 interface{}) *MockFile_SetInode_Call {
	return &MockFile_SetInode_Call{Call: _e.mock.On("SetInode", _a0)}
}

func (_c *MockFile_SetInode_Call) Run(run func(_a0 *nodefs.Inode)) *MockFile_SetInode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*nodefs.Inode))
	})
	return _c
}

func (_c *MockFile_SetInode_Call) Return() *MockFile_SetInode_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockFile_SetInode_Call) RunAndReturn(run func(*nodefs.Inode)) *MockFile_SetInode_Call {
	_c.Call.Return(run)
	return _c
}

// SetLk provides a mock function with given fields: owner, lk, flags
func (_m *MockFile) SetLk(owner uint64, lk *fuse.FileLock, flags uint32) fuse.Status {
	ret := _m.Called(owner, lk, flags)

	if len(ret) == 0 {
		panic("no return value specified for SetLk")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(uint64, *fuse.FileLock, uint32) fuse.Status); ok {
		r0 = rf(owner, lk, flags)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_SetLk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLk'
type MockFile_SetLk_Call struct {
	*mock.Call
}

// SetLk is a helper method to define mock.On call
//   - owner uint64
//   - lk *fuse.FileLock
//   - flags uint32
func (_e *MockFile_Expecter) SetLk(owner interface{}, lk interface{}, flags interface{}) *MockFile_SetLk_Call {
	return &MockFile_SetLk_Call{Call: _e.mock.On("SetLk", owner, lk, flags)}
}

func (_c *MockFile_SetLk_Call) Run(run func(owner uint64, lk *fuse.FileLock, flags uint32)) *MockFile_SetLk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(*fuse.FileLock), args[2].(uint32))
	})
	return _c
}

func (_c *MockFile_SetLk_Call) Return(code fuse.Status) *MockFile_SetLk_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFile_SetLk_Call) RunAndReturn(run func(uint64, *fuse.FileLock, uint32) fuse.Status) *MockFile_SetLk_Call {
	_c.Call.Return(run)
	return _c
}

// SetLkw provides a mock function with given fields: owner, lk, flags
func (_m *MockFile) SetLkw(owner uint64, lk *fuse.FileLock, flags uint32) fuse.Status {
	ret := _m.Called(owner, lk, flags)

	if len(ret) == 0 {
		panic("no return value specified for SetLkw")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(uint64, *fuse.FileLock, uint32) fuse.Status); ok {
		r0 = rf(owner, lk, flags)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_SetLkw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLkw'
type MockFile_SetLkw_Call struct {
	*mock.Call
}

// SetLkw is a helper method to define mock.On call
//   - owner uint64
//   - lk *fuse.FileLock
//   - flags uint32
func (_e *MockFile_Expecter) SetLkw(owner interface{}, lk interface{}, flags interface{}) *MockFile_SetLkw_Call {
	return &MockFile_SetLkw_Call{Call: _e.mock.On("SetLkw", owner, lk, flags)}
}

func (_c *MockFile_SetLkw_Call) Run(run func(owner uint64, lk *fuse.FileLock, flags uint32)) *MockFile_SetLkw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(*fuse.FileLock), args[2].(uint32))
	})
	return _c
}

func (_c *MockFile_SetLkw_Call) Return(code fuse.Status) *MockFile_SetLkw_Call {
	_c.Call.Return(code)
	return _c
}

func (_c *MockFile_SetLkw_Call) RunAndReturn(run func(uint64, *fuse.FileLock, uint32) fuse.Status) *MockFile_SetLkw_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields:
func (_m *MockFile) String() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockFile_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type MockFile_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *MockFile_Expecter) String() *MockFile_String_Call {
	return &MockFile_String_Call{Call: _e.mock.On("String")}
}

func (_c *MockFile_String_Call) Run(run func()) *MockFile_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockFile_String_Call) Return(_a0 string) *MockFile_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_String_Call) RunAndReturn(run func() string) *MockFile_String_Call {
	_c.Call.Return(run)
	return _c
}

// Truncate provides a mock function with given fields: size
func (_m *MockFile) Truncate(size uint64) fuse.Status {
	ret := _m.Called(size)

	if len(ret) == 0 {
		panic("no return value specified for Truncate")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(uint64) fuse.Status); ok {
		r0 = rf(size)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_Truncate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Truncate'
type MockFile_Truncate_Call struct {
	*mock.Call
}

// Truncate is a helper method to define mock.On call
//   - size uint64
func (_e *MockFile_Expecter) Truncate(size interface{}) *MockFile_Truncate_Call {
	return &MockFile_Truncate_Call{Call: _e.mock.On("Truncate", size)}
}

func (_c *MockFile_Truncate_Call) Run(run func(size uint64)) *MockFile_Truncate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *MockFile_Truncate_Call) Return(_a0 fuse.Status) *MockFile_Truncate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_Truncate_Call) RunAndReturn(run func(uint64) fuse.Status) *MockFile_Truncate_Call {
	_c.Call.Return(run)
	return _c
}

// Utimens provides a mock function with given fields: atime, mtime
func (_m *MockFile) Utimens(atime *time.Time, mtime *time.Time) fuse.Status {
	ret := _m.Called(atime, mtime)

	if len(ret) == 0 {
		panic("no return value specified for Utimens")
	}

	var r0 fuse.Status
	if rf, ok := ret.Get(0).(func(*time.Time, *time.Time) fuse.Status); ok {
		r0 = rf(atime, mtime)
	} else {
		r0 = ret.Get(0).(fuse.Status)
	}

	return r0
}

// MockFile_Utimens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Utimens'
type MockFile_Utimens_Call struct {
	*mock.Call
}

// Utimens is a helper method to define mock.On call
//   - atime *time.Time
//   - mtime *time.Time
func (_e *MockFile_Expecter) Utimens(atime interface{}, mtime interface{}) *MockFile_Utimens_Call {
	return &MockFile_Utimens_Call{Call: _e.mock.On("Utimens", atime, mtime)}
}

func (_c *MockFile_Utimens_Call) Run(run func(atime *time.Time, mtime *time.Time)) *MockFile_Utimens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*time.Time), args[1].(*time.Time))
	})
	return _c
}

func (_c *MockFile_Utimens_Call) Return(_a0 fuse.Status) *MockFile_Utimens_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFile_Utimens_Call) RunAndReturn(run func(*time.Time, *time.Time) fuse.Status) *MockFile_Utimens_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function with given fields: data, off
func (_m *MockFile) Write(data []byte, off int64) (uint32, fuse.Status) {
	ret := _m.Called(data, off)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 uint32
	var r1 fuse.Status
	if rf, ok := ret.Get(0).(func([]byte, int64) (uint32, fuse.Status)); ok {
		return rf(data, off)
	}
	if rf, ok := ret.Get(0).(func([]byte, int64) uint32); ok {
		r0 = rf(data, off)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func([]byte, int64) fuse.Status); ok {
		r1 = rf(data, off)
	} else {
		r1 = ret.Get(1).(fuse.Status)
	}

	return r0, r1
}

// MockFile_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockFile_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - data []byte
//   - off int64
func (_e *MockFile_Expecter) Write(data interface{}, off interface{}) *MockFile_Write_Call {
	return &MockFile_Write_Call{Call: _e.mock.On("Write", data, off)}
}

func (_c *MockFile_Write_Call) Run(run func(data []byte, off int64)) *MockFile_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(int64))
	})
	return _c
}

func (_c *MockFile_Write_Call) Return(written uint32, code fuse.Status) *MockFile_Write_Call {
	_c.Call.Return(written, code)
	return _c
}

func (_c *MockFile_Write_Call) RunAndReturn(run func([]byte, int64) (uint32, fuse.Status)) *MockFile_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockFile creates a new instance of MockFile. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFile(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFile {
	mock := &MockFile{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
